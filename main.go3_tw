package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"time"
)

// struct to hold each line
type csvLine struct {
	BuildID            string
	User               string
	BuildReqTime       time.Time
	BuildExecStartTime time.Time
	BuildExecEndTime   time.Time
	BuildDeleted       bool
	BuildExitCode      string
	BuildSize          string
}

// struct to hold time window
type timeWindow struct {
	startTime time.Time
	endTime   time.Time
}

// func to conv strings to time.Time (RFC3339)
func convertTimeFormat(s string) time.Time {
	if s != "" {
		initT, err := time.Parse("01/02/2006", s)
		if err != nil {
			panic(err)
		}
		sT := initT.Format(time.RFC3339)
		t, err := time.Parse(time.RFC3339, sT)
		if err != nil {
			panic(err)
		}
		return t
	}
	t := new(time.Time)
	return *t
}

func (t *timeWindow) setTimeWindow(oTime time.Time, nTime time.Time, tSince time.Time, last int64, unit string, t0 time.Time) {
	fmt.Println("-------------------------------------")
	if (oTime == t0 && nTime == t0) && tSince == t0 && (last == 0 && unit == "") {
		fmt.Println("No indication of time window was given, considering all samples in the file")
		t.startTime = t0
		t.endTime = t0
	} else if (oTime != t0 && nTime != t0) && tSince == t0 && (last == 0 && unit == "") {
		fmt.Printf("Chosen a time window between %v and %v .\n", oTime, nTime)
		t.startTime = oTime
		t.endTime = nTime
	} else if (oTime == t0 && nTime == t0) && tSince != t0 && (last == 0 && unit == "") {
		now := time.Now().Format(time.RFC3339)
		fTime, err := time.Parse(time.RFC3339, now)
		if err != nil {
			panic(err)
		}
		fmt.Printf("Chosen a time window between %v and %v (now).\n", tSince, now)
		t.startTime = tSince
		t.endTime = fTime
	} else if (oTime == t0 && nTime == t0) && tSince == t0 && (last != 0 && unit != "") {
		now := time.Now()
		nrUnits := last
		timeUnit := unit
		var startTime int64
		if timeUnit == "seconds" || timeUnit == "second" || timeUnit == "secs" || timeUnit == "sec" || timeUnit == "s" {
			startTime = now.Unix() - nrUnits
		} else if timeUnit == "minutes" || timeUnit == "minute" || timeUnit == "mins" || timeUnit == "min" {
			startTime = now.Unix() - nrUnits*60
		} else if timeUnit == "hours" || timeUnit == "hour" || timeUnit == "h" {
			startTime = now.Unix() - nrUnits*60*60
		} else if timeUnit == "days" || timeUnit == "day" || timeUnit == "d" {
			startTime = now.Unix() - nrUnits*60*60*24
		} else if timeUnit == "weeks" || timeUnit == "week" || timeUnit == "w" {
			startTime = now.Unix() - nrUnits*60*60*24*7
		} else if timeUnit == "months" || timeUnit == "month" {
			startTime = now.Unix() - nrUnits*60*60*24*30
		} else {
			panic(fmt.Sprintf("Unknown time unit!"))
		}
		sT := time.Unix(startTime, 0).Format(time.RFC3339)
		fmt.Printf("Chosen a time window that goes back %d %s (%s).\n", nrUnits, timeUnit, sT)
		fTime, err := time.Parse(time.RFC3339, sT)
		if err != nil {
			panic(err)
		}
		current, err := time.Parse(time.RFC3339, now.Format(time.RFC3339))
		if err != nil {
			panic(err)
		}
		t.startTime = fTime
		t.endTime = current
	} else {
		panic(fmt.Sprintf("Incompatible time options chosen!"))
	}
}

// func to revert sort and get top 5 most frequent events
func sortTop5(m map[string]int, s string) {
	type kv struct {
		Key   string
		Value int
	}
	var ss []kv
	for k, v := range m {
		ss = append(ss, kv{k, v})
	}

	sort.Slice(ss, func(i, j int) bool {
		return ss[i].Value > ss[j].Value
	})
	i := 1
	for _, kv := range ss {
		if i == 6 {
			break
		}
		fmt.Printf("%d.\"%s\", %s: %d\n", i, kv.Key, s, kv.Value)
		i++
	}
}

func main() {
	// create a slice to hold the structs that contain the data for each line
	var content []csvLine
	// the time.Time zero value
	t0 := new(time.Time)
	//var gOperations = make(map[string]bool)

	//get and deal with cli args
	fileArg := flag.String("file", "", "File to parse. (Required)")
	buildsExec := flag.Bool("buildsExecuted", false, "Report the number of builds executed in a specfic time window")
	topUsers := flag.Bool("topUsers", false, "List the top 5 users Who are the top 5 users by builds and how many builds they have executed in a specific time window ")
	successRate := flag.Bool("successRate", false, "Percentage of successful builds in a specific time window")
	topExitCodes := flag.Bool("topFailures", false, "List the top 5 exit codes for unsucessful builds in a specific time window ")
	oldTime := flag.String("between", "", "Specify the older time window margin")
	newTime := flag.String("and", "", "Specify the newer time window margin")
	since := flag.String("since", "", "Specify a point in time since when the reporting should start")
	last := flag.Int64("last", 0, "Specify a number of units of time (needs \"--unit\") since you would like the reporting to start")
	unit := flag.String("unit", "", "Specify the unit of time (needs \"--last\") you would like the reporting to start (choos from: minutes, hours, days, weeks, months)")
	flag.Parse()
	oTime := convertTimeFormat(*oldTime)
	nTime := convertTimeFormat(*newTime)
	tSince := convertTimeFormat(*since)

	if *fileArg == "" {
		panic(fmt.Sprintf("Please use the \"-file\" option to specify a CSV file!"))
	}

	tw := timeWindow{
		startTime: *t0,
		endTime:   *t0,
	}

	tw.setTimeWindow(oTime, nTime, tSince, *last, *unit, *t0)

	// open CSV file
	file, err := os.Open(*fileArg)
	if err != nil {
		panic(err)
	}
	// make sure we eventually close the CSV file
	defer func() {
		if err = file.Close(); err != nil {
			panic(err)
		}
	}()
	// create a reader for the file
	reader := csv.NewReader(file)

	// if the read line is in the specified time window put it into the content slice
	for {
		line, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			panic(err)
		}
		execEndTime, err := time.Parse(time.RFC3339, line[4])
		if err != nil {
			panic(err)
		}
		bAfterLowerBound := execEndTime.After(tw.startTime)
		bBeforeHigherBound := execEndTime.Before(tw.endTime)
		if (bAfterLowerBound && bBeforeHigherBound) || (tw.startTime == *t0 && tw.endTime == *t0) {
			reqTime, err := time.Parse(time.RFC3339, line[2])
			if err != nil {
				panic(err)
			}
			execStartTime, err := time.Parse(time.RFC3339, line[3])
			if err != nil {
				panic(err)
			}
			bDeleted, err := strconv.ParseBool(line[5])
			if err != nil {
				panic(err)
			}
			content = append(content, csvLine{
				BuildID:            line[0],
				User:               line[1],
				BuildReqTime:       reqTime,
				BuildExecStartTime: execStartTime,
				BuildExecEndTime:   execEndTime,
				BuildDeleted:       bDeleted,
				BuildExitCode:      line[6],
				BuildSize:          line[7],
			})
		}
	}

	if len(content) == 0 {
		panic(fmt.Sprintf("There are no etries in the CSV file matching the chosen time window."))
	}

	if !*buildsExec && !*topUsers && !*successRate && !*topExitCodes {
		panic(fmt.Sprintf("No action was chosen! Please indicate an action that you would like performed!"))
	}
	if *buildsExec {
		fmt.Println("-------------------------------------")
		fmt.Println("Chosen to see how many builds were executed in the relevant time window. ")
		fmt.Println("The number of executed builds is: ", len(content))
		fmt.Println("-------------------------------------")
	}
	if *topUsers {
		fmt.Println("Chosen to see who are the top 5 users in the relevant time window. ")
		fmt.Println("The top 5 Users are:")
		duplicateFrequency := make(map[string]int)
		for _, item := range content {
			_, exist := duplicateFrequency[item.User]
			if exist {
				// if already in the map increase counter by 1
				duplicateFrequency[item.User]++
			} else {
				// else start from 1
				duplicateFrequency[item.User] = 1
			}
		}
		sortTop5(duplicateFrequency, "Builds")
		fmt.Println("-------------------------------------")
	}
	if *successRate {
		fmt.Println("Chosen to see what the build suceess rate was in the relevant time window. ")
		var successes int
		for _, item := range content {
			if item.BuildExitCode == "0" {
				successes = successes + 1
			}
		}
		sRate := successes * 100 / len(content)
		fmt.Printf("The build success rate is: %d %% \n", sRate)
		fmt.Println("-------------------------------------")
	}
	if *topExitCodes {
		fmt.Println("Chosen to see what are the top 5 exit codes for failed builds in the relevant time window. ")
		fmt.Println("The top 5 failure exit codes are:")
		duplicateFrequency := make(map[string]int)
		for _, item := range content {
			if item.BuildExitCode != "0" {
				_, exist := duplicateFrequency[item.BuildExitCode]
				if exist {
					// if already in the map increase counter by 1
					duplicateFrequency[item.BuildExitCode]++
				} else {
					// else start from 1
					duplicateFrequency[item.BuildExitCode] = 1
				}
			}
		}
		sortTop5(duplicateFrequency, "Occurrences")
		fmt.Println("-------------------------------------")
	}
}
