package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"time"
)

var fileArg *string
var buildsExec *bool
var topUsers *bool
var successRate *bool
var topExitCodes *bool
var oldTime *string
var newTime *string
var since *string
var last *int64
var unit *string
var gStartTime time.Time
var gEndTime time.Time
var gOperations = make(map[string]bool)

//var gOperations

type csvLine struct {
	BuildID            string
	User               string
	BuildReqTime       time.Time
	BuildExecStartTime time.Time
	BuildExecEndTime   time.Time
	BuildDeleted       bool
	// BuildExitCode      int64
	BuildExitCode string
	BuildSize     string
}

func convertTimeFormat(s string) time.Time {
	if s != "" {
		initT, err := time.Parse("01/02/2006", s)
		if err != nil {
			panic(err)
		}
		sT := initT.Format(time.RFC3339)
		t, err := time.Parse(time.RFC3339, sT)
		if err != nil {
			panic(err)
		}
		fmt.Println(sT)
		return t
	}
	t := new(time.Time)
	return *t
}

func sortTop5(m map[string]int, s string) {
	// parse https://stackoverflow.com/a/44380276/11013420
	type kv struct {
		Key   string
		Value int
	}
	var ss []kv
	for k, v := range m {
		ss = append(ss, kv{k, v})
	}

	sort.Slice(ss, func(i, j int) bool {
		return ss[i].Value > ss[j].Value
	})
	i := 1
	for _, kv := range ss {
		if i == 6 {
			break
		}
		fmt.Printf("%d.\"%s\", %s: %d\n", i, kv.Key, s, kv.Value)
		i++
	}
}

func main() {
	var aTimeWindow = true
	var content []csvLine
	// this is the time.Time zero value
	t0 := new(time.Time)

	fileArg = flag.String("file", "", "File to parse. (Required)")
	buildsExec = flag.Bool("buildsExecuted", false, "Report the number of builds executed in a specfic time window")
	topUsers = flag.Bool("topUsers", false, "List the top 5 users Who are the top 5 users by builds and how many builds they have executed in a specific time window ")
	successRate = flag.Bool("successRate", false, "Percentage of successful builds in a specific time window")
	topExitCodes = flag.Bool("topFailures", false, "List the top 5 exit codes for unsucessful builds in a specific time window ")
	oldTime = flag.String("between", "", "Specify the older time window margin")
	newTime = flag.String("and", "", "Specify the newer time window margin")
	since = flag.String("since", "", "Specify a point in time since when the reporting should start")
	last = flag.Int64("last", 0, "Specify a number of units of time (needs \"--unit\") since you would like the reporting to start")
	unit = flag.String("unit", "", "Specify the unit of time (needs \"--last\") you would like the reporting to start (choos from: minutes, hours, days, weeks, months)")
	flag.Parse()
	oTime := convertTimeFormat(*oldTime)
	nTime := convertTimeFormat(*newTime)
	tSince := convertTimeFormat(*since)

	if *fileArg == "" {
		panic(fmt.Sprintf("Please use the \"-file\" option to specify a CSV file!"))
	}

	if (oTime == *t0 && nTime == *t0) && tSince == *t0 && (*last == 0 && *unit == "") {
		fmt.Println("No indication of time window was given, considering all samples in the file")
		aTimeWindow = false
		//fmt.Println(aTimeWindow)

	} else if (oTime != *t0 && nTime != *t0) && tSince == *t0 && (*last == 0 && *unit == "") {
		fmt.Printf("Chosen a time window between %v and %v option.\n", oTime, nTime)
		gStartTime = oTime
		gEndTime = nTime

	} else if (oTime == *t0 && nTime == *t0) && tSince != *t0 && (*last == 0 && *unit == "") {
		now := time.Now().Format(time.RFC3339)
		t, err := time.Parse(time.RFC3339, now)
		if err != nil {
			panic(err)
		}
		fmt.Printf("Chosen a time window between %v and %v (now) option.\n", tSince, now)
		gStartTime = tSince
		gEndTime = t

	} else if (oTime == *t0 && nTime == *t0) && tSince == *t0 && (*last != 0 && *unit != "") {
		now := time.Now()
		nrUnits := *last
		timeUnit := *unit
		var startTime int64
		if timeUnit == "seconds" || timeUnit == "second" || timeUnit == "secs" || timeUnit == "sec" || timeUnit == "s" {
			startTime = now.Unix() - nrUnits
		} else if timeUnit == "minutes" || timeUnit == "minute" || timeUnit == "mins" || timeUnit == "min" {
			startTime = now.Unix() - nrUnits*60
		} else if timeUnit == "hours" || timeUnit == "hour" || timeUnit == "h" {
			startTime = now.Unix() - nrUnits*60*60
		} else if timeUnit == "days" || timeUnit == "day" || timeUnit == "d" {
			startTime = now.Unix() - nrUnits*60*60*24
		} else if timeUnit == "weeks" || timeUnit == "week" || timeUnit == "w" {
			startTime = now.Unix() - nrUnits*60*60*24*7
		} else if timeUnit == "months" || timeUnit == "month" {
			startTime = now.Unix() - nrUnits*60*60*24*30
		} else {
			panic(fmt.Sprintf("Unknown time unit!"))
		}
		sT := time.Unix(startTime, 0).Format(time.RFC3339)
		fmt.Printf("Chosen a time window that goes back %d %s (%s).\n", nrUnits, timeUnit, sT)
		t, err := time.Parse(time.RFC3339, sT)
		if err != nil {
			panic(err)
		}
		current, err := time.Parse(time.RFC3339, now.Format(time.RFC3339))
		if err != nil {
			panic(err)
		}
		gStartTime = t
		gEndTime = current
	} else {
		panic(fmt.Sprintf("Incompatible time options chosen!"))
	}

	if !*buildsExec && !*topUsers && !*successRate && !*topExitCodes {
		panic(fmt.Sprintf("Please indicate an action that you would like performed!"))
	}
	if *buildsExec {
		fmt.Println("Chosen to see how many builds were executed in the chosen time window. ")
		gOperations["buildsExec"] = true
	}
	if *topUsers {
		fmt.Println("Chosen to see who are the top 5 users in the chosen time window. ")
		gOperations["topUsers"] = true
	}
	if *successRate {
		fmt.Println("Chosen to see what the build suceess rate was in the chosen time window. ")
		gOperations["successRate"] = true
	}
	if *topExitCodes {
		fmt.Println("Chosen to see what are the top 5 exit codes for failed builds in the chosen time window. ")
		gOperations["topExitCodes"] = true
	}

	file, err := os.Open(*fileArg)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err = file.Close(); err != nil {
			panic(err)
		}
	}()

	// Read File into a Variable
	reader := csv.NewReader(file)

	// Loop through lines & turn into object
	for {
		line, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			panic(err)
		}
		execEndTime, err := time.Parse(time.RFC3339, line[4])
		if err != nil {
			panic(err)
		}
		bAfterLowerBound := execEndTime.After(gStartTime)
		bBeforeHigherBound := execEndTime.Before(gEndTime)
		if (bAfterLowerBound && bBeforeHigherBound) || !aTimeWindow {
			reqTime, err := time.Parse(time.RFC3339, line[2])
			if err != nil {
				panic(err)
			}
			execStartTime, err := time.Parse(time.RFC3339, line[3])
			if err != nil {
				panic(err)
			}
			bDeleted, err := strconv.ParseBool(line[5])
			if err != nil {
				panic(err)
			}
			// iExitCode, err := strconv.ParseInt(line[6], 10, 16)
			// if err != nil {
			// 	panic(err)
			// }
			content = append(content, csvLine{
				BuildID:            line[0],
				User:               line[1],
				BuildReqTime:       reqTime,
				BuildExecStartTime: execStartTime,
				BuildExecEndTime:   execEndTime,
				BuildDeleted:       bDeleted,
				BuildExitCode:      line[6],
				// BuildExitCode:      iExitCode,
				BuildSize: line[7],
			})
		}
	}

	if gOperations["buildsExec"] {
		fmt.Println("-------------------------------------")
		fmt.Println("The number of executed builds was: ", len(content))
		fmt.Println("-------------------------------------")
	}
	if gOperations["topUsers"] {
		fmt.Println("-------------------------------------")
		fmt.Println("The top 5 Users are:")
		duplicateFrequency := make(map[string]int)
		for _, item := range content {
			_, exist := duplicateFrequency[item.User]
			if exist {
				duplicateFrequency[item.User]++ // increase counter by 1 if already in the map
			} else {
				duplicateFrequency[item.User] = 1 // else start counting from 1
			}
		}
		sortTop5(duplicateFrequency, "Builds")
		fmt.Println("-------------------------------------")
	}
	if gOperations["successRate"] {
		var successes int
		for _, item := range content {
			if item.BuildExitCode == "0" {
				successes = successes + 1
			}
		}
		sRate := successes * 100 / len(content)
		fmt.Println("-------------------------------------")
		fmt.Printf("The build success rate is: %d %% \n", sRate)
		fmt.Println("-------------------------------------")
	}
	if gOperations["topExitCodes"] {
		fmt.Println("-------------------------------------")
		fmt.Println("The top 5 failure exit codes are:")
		duplicateFrequency := make(map[string]int)
		for _, item := range content {
			if item.BuildExitCode != "0" {
				_, exist := duplicateFrequency[item.BuildExitCode]
				if exist {
					duplicateFrequency[item.BuildExitCode]++ // increase counter by 1 if already in the map
				} else {
					duplicateFrequency[item.BuildExitCode] = 1 // else start counting from 1
				}
			}
		}

		sortTop5(duplicateFrequency, "Occurrences")
		fmt.Println("-------------------------------------")
	}

}
